#region Copyright
// **************************************************************************************************
// ExpressionExpander.cs
// 
// 
// 
//  Comments
// -----------------------------------------------------
// 	Initial Coding
// 
// 
//                          Copyright 2011 Intersoft Data Labs.
// 
//      All rights are reserved.  Reproduction or transmission in whole or in part, in any form or
//    by any means, electronic, mechanical or otherwise, is prohibited without the prior written
//    consent of the copyright owner.
// *************************************************************************************************
#endregion
namespace INTSOF.Utils.EntityFramework
{
   #region Using Directives

   using System;
   using System.Collections.Generic;
   using System.Linq.Expressions;
   using System.Reflection;

   #endregion

   /// <summary>
   ///  Entity Framework ExpressionExpander for PredicateBuilder
   /// </summary>
   internal class ExpressionExpander : ExpressionVisitor
   {
      /// <summary>AsExpandable string</summary>
      public const string AS_EXPANDABLE = "AsExpandable";

      /// <summary>Compile string</summary>
      public const string COMPILE = "Compile";

      /// <summary>Invoke string</summary>
      public const string INVOKE = "Invoke";

      /// <summary>String that identifies a generic type</summary>
      public const string GENERIC_TYPE_IDENTIFIER = "<>";

      // Replacement parameters - for when invoking a lambda expression.
      #region Constants and Fields

      /// <summary>Local _replace vars</summary>
      private readonly Dictionary<ParameterExpression, Expression> _replacementVariables;

      #endregion

      #region Constructors and Destructors

      /// <summary>Initializes a new instance of the <see cref="ExpressionExpander"/> class.</summary>
      internal ExpressionExpander() { }

      /// <summary>Prevents a default instance of the <see cref="ExpressionExpander"/> class from being created.</summary>
      /// <param name="replacementVariables">The replace vars.</param>
      private ExpressionExpander(Dictionary<ParameterExpression, Expression> replacementVariables)
      {
         this._replacementVariables = replacementVariables;
      }

      #endregion

      #region Methods

      /// <summary>Flatten calls to Invoke so that Entity Framework can understand it. Calls to Invoke are generated by PredicateBuilder.</summary>
      /// <param name="expression">The iv.</param>
      /// <returns>A System.Linq.Expressions.Expression</returns>
      /// <exception cref="InvalidOperationException">Invoke cannot be called recursively - try using a temporary variable.</exception>
      protected override Expression VisitInvocation(InvocationExpression expression)
      {
         Expression target = expression.Expression;

         if (target is MemberExpression)
         {
            target = this.TransformExpression((MemberExpression)target);
         }

         if (target is ConstantExpression)
         {
            target = ((ConstantExpression)target).Value as Expression;
         }

         LambdaExpression lambda = (LambdaExpression)target;

         Dictionary<ParameterExpression, Expression> replacementVariables = this._replacementVariables.IsNull()
                                              ? new Dictionary<ParameterExpression, Expression>()
                                              : new Dictionary<ParameterExpression, Expression>(this._replacementVariables);

         try
         {
            for (int i = 0; i < lambda.Parameters.Count; i++)
            {
               replacementVariables.Add(lambda.Parameters[i], expression.Arguments[i]);
            }
         }
         catch (ArgumentException ex)
         {
            throw new InvalidOperationException("Invoke cannot be called recursively - try using a temporary variable.", ex);
         }

         return new ExpressionExpander(replacementVariables).Visit(lambda.Body);
      }

      /// <summary>Visits the member access.</summary>
      /// <param name="expression">The expression.</param>
      /// <returns>A System.Linq.Expressions.Expression</returns>
      protected override Expression VisitMemberAccess(MemberExpression expression)
      {
         // Strip out any references to expressions captured by outer variables - LINQ to SQL can't handle these:
         return expression.Member.DeclaringType.Name.StartsWith(GENERIC_TYPE_IDENTIFIER)
            ? this.TransformExpression(expression)
            : base.VisitMemberAccess(expression);
      }

      /// <summary>Visits the method call.</summary>
      /// <param name="expression">The m.</param>
      /// <returns>A System.Linq.Expressions.Expression</returns>
      /// <exception cref="InvalidOperationException">
      /// </exception>
      protected override Expression VisitMethodCall(MethodCallExpression expression)
      {
         if (expression.Method.Name == INVOKE && expression.Method.DeclaringType == typeof(Extensions))
         {
            Expression target = expression.Arguments[0];

            if (target is MemberExpression)
            {
               target = this.TransformExpression((MemberExpression)target);
            }

            if (target is ConstantExpression)
            {
               target = ((ConstantExpression)target).Value as Expression;
            }

            LambdaExpression lambda = (LambdaExpression)target;

            Dictionary<ParameterExpression, Expression> replacementVariables = this._replacementVariables.IsNull()
                                                 ? new Dictionary<ParameterExpression, Expression>()
                                                 : new Dictionary<ParameterExpression, Expression>(this._replacementVariables);

            try
            {
               for (int i = 0; i < lambda.Parameters.Count; i++)
               {
                  replacementVariables.Add(lambda.Parameters[i], expression.Arguments[i + 1]);
               }
            }
            catch (ArgumentException ex)
            {
               throw new InvalidOperationException("Invoke cannot be called recursively - try using a temporary variable.", ex);
            }

            return new ExpressionExpander(replacementVariables).Visit(lambda.Body);
         }

         // Expand calls to an expression's Compile() method:
         if (expression.Method.Name == COMPILE && expression.Object is MemberExpression)
         {
            var memberExpression = (MemberExpression)expression.Object;

            Expression newExpression = this.TransformExpression(memberExpression);

            if (newExpression != memberExpression)
            {
               return newExpression;
            }
         }

         // Strip out any nested calls to AsExpandable():
         if (expression.Method.Name == AS_EXPANDABLE && expression.Method.DeclaringType == typeof(Extensions))
         {
            return expression.Arguments[0];
         }

         return base.VisitMethodCall(expression);
      }

      /// <summary>Visits the parameter.</summary>
      /// <param name="expression">The p.</param>
      /// <returns>A System.Linq.Expressions.Expression</returns>
      protected override Expression VisitParameter(ParameterExpression expression)
      {
         return this._replacementVariables.IsNotNull() && this._replacementVariables.ContainsKey(expression)
                   ? this._replacementVariables[expression]
                   : base.VisitParameter(expression);
      }

      /// <summary>Transforms the expression.</summary>
      /// <param name="expression">The expression.</param>
      /// <returns>A System.Linq.Expressions.Expression</returns>
      private Expression TransformExpression(MemberExpression expression)
      {
         // Collapse captured outer variables
         if (expression.IsNull()
            || !(expression.Member is FieldInfo)
            || !expression.Member.ReflectedType.IsNestedPrivate
            || !expression.Member.ReflectedType.Name.StartsWith(GENERIC_TYPE_IDENTIFIER))
         {
            // captured outer variable
            return expression;
         }

         ConstantExpression constantExpression = expression.Expression as ConstantExpression;

         if (constantExpression.IsNotNull())
         {
            object value = constantExpression.Value;

            if (value.IsNull())
            {
               return expression;
            }

            Type type = value.GetType();

            if (!type.IsNestedPrivate || !type.Name.StartsWith(GENERIC_TYPE_IDENTIFIER))
            {
               return expression;
            }

            FieldInfo fieldInfo = (FieldInfo)expression.Member;

            object result = fieldInfo.GetValue(value);

            return result is Expression
               ? this.Visit((Expression)result)
               : expression;
         }

         return expression;
      }
      #endregion
   }
}